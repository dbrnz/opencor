diff --git lib/matplotlib/backends/backend_qt5.py lib/matplotlib/backends/backend_qt5.py
index 0df0f764d..170077052 100644
--- lib/matplotlib/backends/backend_qt5.py
+++ lib/matplotlib/backends/backend_qt5.py
@@ -18,7 +18,7 @@ from matplotlib.figure import Figure
 from matplotlib.backend_managers import ToolManager
 
 from .qt_compat import (
-    QtCore, QtGui, QtWidgets, _getSaveFileName, is_pyqt5, __version__, QT_API)
+    QtCore, QtGui, QtWidgets, _getSaveFileName, is_pyqt5, is_qt5, __version__, QT_API)
 
 backend_version = __version__
 
@@ -104,9 +104,9 @@ def _create_qApp():
 
     if qApp is None:
         app = QtWidgets.QApplication.instance()
-        if app is None:
+        if is_pyqt5 and app is None:
             # check for DISPLAY env variable on X11 build of Qt
-            if is_pyqt5():
+            if is_qt5():
                 try:
                     from PyQt5 import QtX11Extras
                     is_x11_build = True
@@ -124,7 +124,7 @@ def _create_qApp():
         else:
             qApp = app
 
-    if is_pyqt5():
+    if is_qt5():
         try:
             qApp.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps)
             qApp.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)
@@ -134,7 +134,7 @@ def _create_qApp():
 
 def _allow_super_init(__init__):
     """
-    Decorator for ``__init__`` to allow ``super().__init__`` on PyQt4/PySide2.
+    Decorator for ``__init__`` to allow ``super().__init__`` on PyQt4/PySide2/PythonQt.
     """
 
     if QT_API == "PyQt5":
@@ -142,8 +142,8 @@ def _allow_super_init(__init__):
         return __init__
 
     else:
-        # To work around lack of cooperative inheritance in PyQt4, PySide,
-        # and PySide2, when calling FigureCanvasQT.__init__, we temporarily
+        # To work around lack of cooperative inheritance in PyQt4, PySide, PySide2
+        # and PythonQt, when calling FigureCanvasQT.__init__, we temporarily
         # patch QWidget.__init__ by a cooperative version, that first calls
         # QWidget.__init__ with no additional arguments, and then finds the
         # next class in the MRO with an __init__ that does support cooperative
@@ -159,7 +159,7 @@ def _allow_super_init(__init__):
             next_coop_init = next(
                 cls for cls in mro[mro.index(QtWidgets.QWidget) + 1:]
                 if cls.__module__.split(".")[0] not in [
-                    "PyQt4", "sip", "PySide", "PySide2", "Shiboken"])
+                    "PyQt4", "sip", "PySide", "PySide2", "Shiboken", "PythonQt"])
             next_coop_init.__init__(self, *args, **kwargs)
 
         @functools.wraps(__init__)
@@ -542,8 +542,16 @@ class FigureCanvasQT(QtWidgets.QWidget, FigureCanvasBase):
 class MainWindow(QtWidgets.QMainWindow):
     closing = QtCore.Signal()
 
+    def __init__(self):
+        QtGui.QMainWindow.__init__(self)
+        self._closeCallbacks = []
+
+    def connectClosing(self, callback):
+        self._closeCallbacks.append(callback)
+
     def closeEvent(self, event):
-        self.closing.emit()
+        for callback in self._closeCallbacks:
+            callback()
         QtWidgets.QMainWindow.closeEvent(self, event)
 
 
@@ -566,8 +574,9 @@ class FigureManagerQT(FigureManagerBase):
         FigureManagerBase.__init__(self, canvas, num)
         self.canvas = canvas
         self.window = MainWindow()
-        self.window.closing.connect(canvas.close_event)
-        self.window.closing.connect(self._widgetclosed)
+        self.window.setAttribute(QtCore.Qt.WA_DeleteOnClose)
+        self.window.connectClosing(canvas.close_event)
+        self.window.connectClosing(self._widgetclosed)
 
         self.window.setWindowTitle("Figure %d" % num)
         image = os.path.join(matplotlib.rcParams['datapath'],
@@ -694,7 +703,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
     def __init__(self, canvas, parent, coordinates=True):
         """ coordinates: should we show the coordinates on the right? """
         self.canvas = canvas
-        self.parent = parent
+        self._parent = parent
         self.coordinates = coordinates
         self._actions = {}
         """A mapping of toolitem method names to their QActions"""
@@ -703,7 +712,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
         NavigationToolbar2.__init__(self, canvas)
 
     def _icon(self, name):
-        if is_pyqt5():
+        if is_qt5():
             name = name.replace('.png', '_large.png')
         pm = QtGui.QPixmap(os.path.join(self.basedir, name))
         if hasattr(pm, 'setDevicePixelRatio'):
@@ -750,16 +759,16 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
         # Esthetic adjustments - we need to set these explicitly in PyQt5
         # otherwise the layout looks different - but we don't want to set it if
         # not using HiDPI icons otherwise they look worse than before.
-        if is_pyqt5():
+        if is_qt5():
             self.setIconSize(QtCore.QSize(24, 24))
             self.layout().setSpacing(12)
 
-    if is_pyqt5():
+    if is_qt5():
         # For some reason, self.setMinimumHeight doesn't seem to carry over to
         # the actual sizeHint, so override it instead in order to make the
         # aesthetic adjustments noted above.
         def sizeHint(self):
-            size = super().sizeHint()
+            size = QtWidgets.QToolBar.sizeHint(self)
             size.setHeight(max(48, size.height()))
             return size
 
@@ -767,7 +776,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
         allaxes = self.canvas.figure.get_axes()
         if not allaxes:
             QtWidgets.QMessageBox.warning(
-                self.parent, "Error", "There are no axes to edit.")
+                self._parent, "Error", "There are no axes to edit.")
             return
         elif len(allaxes) == 1:
             axes, = allaxes
@@ -781,7 +790,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
                             type(axes).__name__, id(axes)))
                 titles.append(name)
             item, ok = QtWidgets.QInputDialog.getItem(
-                self.parent, 'Customize', 'Select axes:', titles, 0, False)
+                self._parent, 'Customize', 'Select axes:', titles, 0, False)
             if ok:
                 axes = allaxes[titles.index(item)]
             else:
@@ -823,7 +832,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
     def configure_subplots(self):
         image = os.path.join(matplotlib.rcParams['datapath'],
                              'images', 'matplotlib.png')
-        dia = SubplotToolQt(self.canvas.figure, self.parent)
+        dia = SubplotToolQt(self.canvas.figure, self._parent)
         dia.setWindowIcon(QtGui.QIcon(image))
         dia.exec_()
 
@@ -845,7 +854,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
             filters.append(filter)
         filters = ';;'.join(filters)
 
-        fname, filter = _getSaveFileName(self.parent,
+        fname, filter = _getSaveFileName(self._parent,
                                          "Choose a filename to save to",
                                          start, filters, selectedFilter)
         if fname:
@@ -1126,4 +1135,6 @@ class _BackendQT5(_Backend):
     def mainloop():
         # allow KeyboardInterrupt exceptions to close the plot window.
         signal.signal(signal.SIGINT, signal.SIG_DFL)
-        qApp.exec_()
+        # PythonQt is already running the event loop
+        if QT_API != "PythonQt":
+            qApp.exec_()
diff --git lib/matplotlib/backends/qt_compat.py lib/matplotlib/backends/qt_compat.py
index b0fa0a907..10838bf6c 100644
--- lib/matplotlib/backends/qt_compat.py
+++ lib/matplotlib/backends/qt_compat.py
@@ -22,12 +22,14 @@ from matplotlib import rcParams
 QT_API_PYQT5 = "PyQt5"
 QT_API_PYSIDE2 = "PySide2"
 QT_API_PYQTv2 = "PyQt4v2"
+QT_API_PYTHONQT = 'PythonQt' # use PythonQt API for Qt5
 QT_API_PYSIDE = "PySide"
 QT_API_PYQT = "PyQt4"   # Use the old sip v1 API (Py3 defaults to v2).
 QT_API_ENV = os.environ.get("QT_API")
 # Mapping of QT_API_ENV to requested binding.  ETS does not support PyQt4v1.
 # (https://github.com/enthought/pyface/blob/master/pyface/qt/__init__.py)
 _ETS = {"pyqt5": QT_API_PYQT5, "pyside2": QT_API_PYSIDE2,
+        "pythonqt": QT_API_PYTHONQT,
         "pyqt": QT_API_PYQTv2, "pyside": QT_API_PYSIDE,
         None: None}
 # First, check if anything is already imported.
@@ -37,6 +39,9 @@ if "PyQt5" in sys.modules:
 elif "PySide2" in sys.modules:
     QT_API = QT_API_PYSIDE2
     dict.__setitem__(rcParams, "backend.qt5", QT_API)
+elif 'PythonQt' in sys.modules:
+    QT_API = QT_API_PYTHONQT
+    dict.__setitem__(rcParams, "backend.qt5", QT_API)
 elif "PyQt4" in sys.modules:
     QT_API = QT_API_PYQTv2
     dict.__setitem__(rcParams, "backend.qt4", QT_API)
@@ -66,11 +71,11 @@ else:
     except KeyError:
         raise RuntimeError(
             "The environment variable QT_API has the unrecognized value {!r};"
-            "valid values are 'pyqt5', 'pyside2', 'pyqt', and 'pyside'")
+            "valid values are 'pyqt5', 'pyside2', 'pythonqt', pyqt', and 'pyside'")
 
 
 def _setup_pyqt5():
-    global QtCore, QtGui, QtWidgets, __version__, is_pyqt5, _getSaveFileName
+    global QtCore, QtGui, QtWidgets, __version__, is_pyqt5, is_qt5, _getSaveFileName
 
     if QT_API == QT_API_PYQT5:
         from PyQt5 import QtCore, QtGui, QtWidgets
@@ -78,18 +83,46 @@ def _setup_pyqt5():
         QtCore.Signal = QtCore.pyqtSignal
         QtCore.Slot = QtCore.pyqtSlot
         QtCore.Property = QtCore.pyqtProperty
+        _getSaveFileName = QtWidgets.QFileDialog.getSaveFileName
     elif QT_API == QT_API_PYSIDE2:
         from PySide2 import QtCore, QtGui, QtWidgets, __version__
+        _getSaveFileName = QtWidgets.QFileDialog.getSaveFileName
+    elif QT_API == QT_API_PYTHONQT:  # try importing PythonQt
+        from PythonQt import QtCore, QtGui
+        __version__ = "3.2"
+        __version_info__ = "-"
+
+        # PythonQt does not yet support a getSaveFileName variant returning the selected filter
+        def _getSaveFileName(*args, **kwargs):
+            return (QtGui.QFileDialog.getSaveFileName(*args, **kwargs), None)
+
+        # Provide color getters
+        def getHslF(c):
+            return (c.hslHueF(), c.hslSaturationF(), c.lightnessF(), c.alphaF())
+
+        def getHsvF(c):
+            return (c.hueF(), c.saturationF(), c.valueF(), c.alphaF())
+
+        def getRgbF(c):
+            return (c.redF(), c.greenF(), c.blueF(), c.alphaF())
+
+        QtGui.QColor.getHslF = getHslF
+        QtGui.QColor.getHsvF = getHsvF
+        QtGui.QColor.getRgbF = getRgbF
+
+        # PythonQt doesn't have a separate QtWidgets module
+        QtWidgets = QtGui
     else:
         raise ValueError("Unexpected value for the 'backend.qt5' rcparam")
-    _getSaveFileName = QtWidgets.QFileDialog.getSaveFileName
 
     def is_pyqt5():
-        return True
+        return QT_API in [QT_API_PYQT5, QT_API_PYSIDE2]
 
+    def is_qt5():
+        return True
 
 def _setup_pyqt4():
-    global QtCore, QtGui, QtWidgets, __version__, is_pyqt5, _getSaveFileName
+    global QtCore, QtGui, QtWidgets, __version__, is_pyqt5, is_qt5, _getSaveFileName
 
     def _setup_pyqt4_internal(api):
         global QtCore, QtGui, QtWidgets, \
@@ -137,8 +170,11 @@ def _setup_pyqt4():
     def is_pyqt5():
         return False
 
+    def is_qt5():
+        return False
+
 
-if QT_API in [QT_API_PYQT5, QT_API_PYSIDE2]:
+if QT_API in [QT_API_PYQT5, QT_API_PYSIDE2, QT_API_PYTHONQT]:
     _setup_pyqt5()
 elif QT_API in [QT_API_PYQTv2, QT_API_PYSIDE, QT_API_PYQT]:
     _setup_pyqt4()
diff --git lib/matplotlib/backends/qt_editor/formlayout.py lib/matplotlib/backends/qt_editor/formlayout.py
index d4cf62601..1fb5037f4 100644
--- lib/matplotlib/backends/qt_editor/formlayout.py
+++ lib/matplotlib/backends/qt_editor/formlayout.py
@@ -67,8 +67,9 @@ class ColorButton(QtWidgets.QPushButton):
 
     def choose_color(self):
         color = QtWidgets.QColorDialog.getColor(
-            self._color, self.parentWidget(), "",
-            QtWidgets.QColorDialog.ShowAlphaChannel)
+            self._color, self.parentWidget(), "")
+        ## PythonQt doesn't support QColorDialog.ColorDialogOptions
+        ##    QtWidgets.QColorDialog.ShowAlphaChannel)
         if color.isValid():
             self.set_color(color)
 
@@ -200,7 +201,7 @@ class FontLayout(QtWidgets.QGridLayout):
 
 def is_edit_valid(edit):
     text = edit.text()
-    state = edit.validator().validate(text, 0)[0]
+    state = edit.validator().validate(text, 0)
 
     return state == QtGui.QDoubleValidator.Acceptable
 
diff --git lib/matplotlib/backends/qt_editor/formsubplottool.py lib/matplotlib/backends/qt_editor/formsubplottool.py
index a0914cab8..50a5ebed1 100644
--- lib/matplotlib/backends/qt_editor/formsubplottool.py
+++ lib/matplotlib/backends/qt_editor/formsubplottool.py
@@ -54,3 +54,9 @@ class UiSubplotTool(QtWidgets.QDialog):
             right.addWidget(widget)
 
         self._widgets["Close"].setFocus()
+
+    def accept(self):
+        QtWidgets.QDialog.accept(self)
+
+    def close(self):
+        QtWidgets.QDialog.close(self)
diff --git lib/matplotlib/pyplot.py lib/matplotlib/pyplot.py
index 32c858452..9df91e02b 100644
--- lib/matplotlib/pyplot.py
+++ lib/matplotlib/pyplot.py
@@ -123,6 +123,10 @@ def install_repl_displayhook():
 
             ipython_gui_name = backend2gui.get(get_backend())
             if ipython_gui_name:
+                if ipython_gui_name.startswith('qt'):
+                    from matplotlib.backends.qt_compat import QT_API
+                    if QT_API == 'PythonQt':
+                        ipython_gui_name = 'pythonqt'
                 ip.enable_gui(ipython_gui_name)
         else:
             _INSTALL_FIG_OBSERVER = True
